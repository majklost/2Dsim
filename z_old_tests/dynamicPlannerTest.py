from z_old_tests.TestTemplate import TestTemplate
from _old_src.helpers.objectLibrary import Agent, Obstacle
from _old_src.helpers.helperFunctions import render_goal
from _old_src.RRTNode import RRTNodeTimed
import pymunk
from _old_src.dynamicLocalPlanner import LocalPlannerCalc, LocalPlannerSim
import pygame
from pymunk import pygame_util
W = H = 800
# Simple test with one static obstacle and one moving obstacle
# Goal 2 is behind static obstacle
# Goal 1 is behind moving obstacle, reachability by planner is dependent on obstacle velocity
# Planner makes a straight line between start and goal and moves with constant velocity


# OBSTACLE_VELOCITY = 100,0,0 #is reachable
OBSTACLE_VELOCITY = 5, 0, 0  # is not reachable


class DynamicPlannerTest(TestTemplate):

    def __init__(self, start, goal, usePlannerSim=False):
        super().__init__(W, H, 80)
        self.start = start
        self.goal = goal
        self.cnt = 0
        self.usePlannerSim = usePlannerSim

    # can be used for seeing which positions is the planner checking - makes a screenshot every iteration to debug folder
    def debugclbck(self, space):
        if self.cnt > 100:
            return
        draw_options = pymunk.pygame_util.DrawOptions(self.display)
        self.display.fill((255, 255, 255))
        space.debug_draw(draw_options)
        pygame.display.update()
        # save the image
        pygame.image.save(self.display, f"./debug/screenshot{self.cnt}.jpg")
        self.cnt += 1

    def setup(self):
        # objects
        agent = Agent(self.start.x, self.start.y, 50, 50)
        agent.add(self.space)

        # the one that should be plausible to reach via line
        block = Obstacle(100, 400, 200, 100)
        block.set_body_type(pymunk.Body.KINEMATIC)
        block.body.velocity = OBSTACLE_VELOCITY[0], OBSTACLE_VELOCITY[1]
        block.body.angular_velocity = OBSTACLE_VELOCITY[2]
        block.add(self.space)

        # the one that should be blocked
        block2 = Obstacle(400, 700, 100, 200)
        block2.add(self.space)

        # planner
        if self.usePlannerSim:
            lp = LocalPlannerSim(self.space, agent.shape)
        else:
            lp = LocalPlannerCalc(self.space, agent.shape, block.body, obstacle_velocity=OBSTACLE_VELOCITY, dt=1 / 100)
        lp.verbose = True  # say if path blocked

        # if you want to see the planner in action
        # lp.set_debug_callback(self.debugclbck)

        # nodes generated by planner
        chpoints = lp.check_path(self.start, self.goal)
        print(chpoints)

    def post_render(self):
        render_goal(self.display, self.goal)


if __name__ == "__main__":
    START = RRTNodeTimed(50, 750, 0, 0)
    GOAL = RRTNodeTimed(50, 50, 0, 5)  # behind moving obstacle
    GOAL2 = RRTNodeTimed(700, 700, 0, 5)  # behind static obstacle
    t = DynamicPlannerTest(START, GOAL, usePlannerSim=False)
    t.run()
